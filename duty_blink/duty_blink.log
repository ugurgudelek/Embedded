KCPSM6 Assembler log file for program 'C:\Users\ugurg\OneDrive\Learnings\Courses\BIL569 Embedded\HW1\src\duty_blink\duty_blink.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 31 May 2017
Assembly timestamp: 22:08:19

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 049 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 74
Memory locations available: 4022


Assembly listing

 Addr Code                          Instruction

 000                                NAMEREG s3, led_stat
 000                                NAMEREG s1, duty_cycle_reg
 000                                NAMEREG s2, direction_reg
 000                                NAMEREG sA, delayA_reg
 000                                NAMEREG sB, delayB_reg
 000                                NAMEREG sC, delayC_reg
 000                                NAMEREG sD, delay_reg
 000                                NAMEREG sE, delay_usec_reg
 000                                CONSTANT led_port, 00
 000  01101                         LOAD s1[duty_cycle_reg], 01
 001  012FF                         LOAD s2[direction_reg], FF
 002  22048                         JUMP 048[main]
 003                                ;==========SUBROUTINES=================
 003                                ; 255*255*190 ~= 12.5M
 003                                ; delay routine has 2 INST so 25M INST in total we have
 003                                ; 1INST = 2clock cycle so 50M clock cycle we have
 003                                ; device frequency is 100Mhz so that 50M clock took 0.5 sec.
 003                                ; half cycle took 0.5 sec => full cycle 1sec. :)
 003                 delay_500msec: 
 003  01A00                         LOAD sA[delayA_reg], 00                ;count FF - 00 = FF || 255'd
 004  01B00                         LOAD sB[delayB_reg], 00                ;count FF - 00 = FF || 255'd
 005  01C41                         LOAD sC[delayC_reg], 41                ;count FF - 41 = BE || 190'd
 006                                ; delay_sec ~= (FF-delayA_reg)*(FF-delayB_reg)*(FF-delayC_reg)*2*2/100M sec
 006                         delay: 
 006  11A01                         ADD sA[delayA_reg], 01
 007  36006                         JUMP NZ, 006[delay]
 008  11B01                         ADD sB[delayB_reg], 01
 009  36006                         JUMP NZ, 006[delay]
 00A  11C01                         ADD sC[delayC_reg], 01
 00B  36006                         JUMP NZ, 006[delay]
 00C  25000                         RETURN 
 00D                                ; 50clk_cycle = 1u sec
 00D                                ; 25INST = 50clk_cycle
 00D              delay_1micro_sec: 
 00D  01E0C                         LOAD sE[delay_usec_reg], 0C            ;12'd
 00E         delay_1micro_sec_loop: 
 00E  19E01                         SUB sE[delay_usec_reg], 01
 00F  3600E                         JUMP NZ, 00E[delay_1micro_sec_loop]
 010  25000                         RETURN 
 011         delay_high_duty_cycle: 
 011  00D10                         LOAD sD[delay_reg], s1[duty_cycle_reg]
 012  20018                         CALL 018[delay_reg_loop]
 013  25000                         RETURN 
 014          delay_low_duty_cycle: 
 014  01DFF                         LOAD sD[delay_reg], FF
 015  18D10                         SUB sD[delay_reg], s1[duty_cycle_reg]
 016  20018                         CALL 018[delay_reg_loop]
 017  25000                         RETURN 
 018                                ; loop until delay_reg is zero
 018                                ;2 INST
 018                delay_reg_loop: 
 018  19D01                         SUB sD[delay_reg], 01
 019  36018                         JUMP NZ, 018[delay_reg_loop]
 01A  25000                         RETURN 
 01B                                ;keep led off
 01B                       led_off: 
 01B  01300                         LOAD s3[led_stat], 00
 01C  2D300                         OUTPUT s3[led_stat], 00[led_port]
 01D                                ;CALL assign_low_duty_cycle
 01D                                ;CALL n_cycle_delay       ;call delay for waiting here
 01D  25000                         RETURN 
 01E                                ;keep led on
 01E                        led_on: 
 01E  013FF                         LOAD s3[led_stat], FF
 01F  2D300                         OUTPUT s3[led_stat], 00[led_port]
 020                                ;CALL assign_high_duty_cycle
 020                                ;CALL n_cycle_delay       ;call delay for waiting here
 020  25000                         RETURN 
 021                   led_on_wait: 
 021  2001E                         CALL 01E[led_on]
 022  20011                         CALL 011[delay_high_duty_cycle]
 023  25000                         RETURN 
 024                  led_off_wait: 
 024  2001B                         CALL 01B[led_off]
 025  20014                         CALL 014[delay_low_duty_cycle]
 026  25000                         RETURN 
 027                                ;this is one period of duty cycled signal. 2*255 INST
 027                    one_period: 
 027  1D100                         COMPARE s1[duty_cycle_reg], 00
 028  34021                         CALL NZ, 021[led_on_wait]              ;2*(duty_cycle_reg) INST
 029  1D1FF                         COMPARE s1[duty_cycle_reg], FF
 02A  34024                         CALL NZ, 024[led_off_wait]             ;2*(255-duty_cycle_reg) INST
 02B  25000                         RETURN 
 02C                        thread: 
 02C  01A00                         LOAD sA[delayA_reg], 00                ;count FF - 00 = FF || 255'd
 02D  01BFB                         LOAD sB[delayB_reg], FB                ;count FF - 00 = FF || 255'd
 02E  01CFF                         LOAD sC[delayC_reg], FF                ;count FF - 41 = BE || 190'd
 02F                  thread_delay: 
 02F  20027                         CALL 027[one_period]                   ;this is one period of duty cycled signal. 50*255 INST
 030  11A01                         ADD sA[delayA_reg], 01
 031  3602F                         JUMP NZ, 02F[thread_delay]
 032  11B01                         ADD sB[delayB_reg], 01
 033  3602F                         JUMP NZ, 02F[thread_delay]
 034  11C01                         ADD sC[delayC_reg], 01
 035  3602F                         JUMP NZ, 02F[thread_delay]
 036                                ;check for direction
 036  1D100                         COMPARE s1[duty_cycle_reg], 00
 037  30042                         CALL Z, 042[change_direction]          ; equal
 038  1D1FF                         COMPARE s1[duty_cycle_reg], FF
 039  30042                         CALL Z, 042[change_direction]          ; equal
 03A  2003C                         CALL 03C[calc_duty_cycle]
 03B  25000                         RETURN 
 03C               calc_duty_cycle: 
 03C                                ; if direction_reg says increment then increment, o.w decrement
 03C  1D2FF                         COMPARE s2[direction_reg], FF
 03D  32040                         JUMP Z, 040[increment_duty_cycle]      ; equal
 03E          decrement_duty_cycle: ;not equal
 03E  19101                         SUB s1[duty_cycle_reg], 01
 03F  25000                         RETURN 
 040          increment_duty_cycle: 
 040  11101                         ADD s1[duty_cycle_reg], 01
 041  25000                         RETURN 
 042              change_direction: 
 042  1D2FF                         COMPARE s2[direction_reg], FF
 043  32046                         JUMP Z, 046[direction_00]              ; equal
 044                                ;not equal
 044  012FF                         LOAD s2[direction_reg], FF
 045  25000                         RETURN 
 046                  direction_00: 
 046  01200                         LOAD s2[direction_reg], 00
 047  25000                         RETURN 
 048                                ;==========SUBROUTINES=================
 048                                ;============MAIN======================
 048                                ; one period of PWM
 048                                ; it takes 4u sec to complete
 048                          main: 
 048  2002C                         CALL 02C[thread]                       ;
 049  22048                         JUMP 048[main]                         ;infinite loop
 04A                                ;============MAIN======================


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\ugurg\OneDrive\Learnings\Courses\BIL569 Embedded\HW1\src\duty_blink\duty_blink.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   22'd         
 timestamp_minutes 08'd         
 timestamp_seconds 19'd         
 datestamp_year    17'd         
 datestamp_month   5'd          
 datestamp_day     31'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 led_port          00           duty_blink.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "31 May 2017"  
 timestamp$        "22:08:19"     



List of line labels

   Label                   Addr  Source PSM File

 * delay_500msec           003   duty_blink.psm
   delay                   006   duty_blink.psm
 * delay_1micro_sec        00D   duty_blink.psm
   delay_1micro_sec_loop   00E   duty_blink.psm
   delay_high_duty_cycle   011   duty_blink.psm
   delay_low_duty_cycle    014   duty_blink.psm
   delay_reg_loop          018   duty_blink.psm
   led_off                 01B   duty_blink.psm
   led_on                  01E   duty_blink.psm
   led_on_wait             021   duty_blink.psm
   led_off_wait            024   duty_blink.psm
   one_period              027   duty_blink.psm
   thread                  02C   duty_blink.psm
   thread_delay            02F   duty_blink.psm
   calc_duty_cycle         03C   duty_blink.psm
 * decrement_duty_cycle    03E   duty_blink.psm
   increment_duty_cycle    040   duty_blink.psm
   change_direction        042   duty_blink.psm
   direction_00            046   duty_blink.psm
   main                    048   duty_blink.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             15
 STAR              -

 AND               -
 OR                -
 XOR               -

 ADD               7
 ADDCY             -
 SUB               4
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE           6
 COMPARECY         -

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               -
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             -
 OUTPUT            2
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             12
 JUMP@             -
 CALL             13
 CALL@             -
 RETURN           15
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
