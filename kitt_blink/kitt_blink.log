KCPSM6 Assembler log file for program 'C:\Users\ugurg\OneDrive\Learnings\Courses\BIL569 Embedded\HW1\src\kitt_blink\kitt_blink.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 31 May 2017
Assembly timestamp: 22:02:13

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 04F hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 80
Memory locations available: 4016


Assembly listing

 Addr Code                                      Instruction

 000                                            NAMEREG s3, led_stat
 000                                            NAMEREG s4, which_led_on_reg
 000                                            NAMEREG s5, blink_this_reg
 000                                            NAMEREG s1, duty_cycle_reg
 000                                            NAMEREG s2, direction_reg
 000                                            NAMEREG sA, delayA_reg
 000                                            NAMEREG sB, delayB_reg
 000                                            NAMEREG sD, delay_reg
 000                                            NAMEREG sF, temp_reg
 000                                            CONSTANT led_port, 00
 000  011FF                                     LOAD s1[duty_cycle_reg], FF
 001  01200                                     LOAD s2[direction_reg], 00
 002  01401                                     LOAD s4[which_led_on_reg], 01
 003  2204E                                     JUMP 04E[main]
 004                                            ;==========SUBROUTINES=================
 004                                            ; loop until delay_reg is zero
 004                                            ;2 INST*delay_reg
 004                            delay_reg_loop: 
 004  19D01                                     SUB sD[delay_reg], 01
 005  36004                                     JUMP NZ, 004[delay_reg_loop]
 006  25000                                     RETURN 
 007                                            ;keep led off
 007                                   led_off: 
 007  01300                                     LOAD s3[led_stat], 00
 008  2D300                                     OUTPUT s3[led_stat], 00[led_port]
 009  25000                                     RETURN 
 00A                                            ;set led on wrt blink_this_reg
 00A                                    led_on: 
 00A  00350                                     LOAD s3[led_stat], s5[blink_this_reg]
 00B  2D300                                     OUTPUT s3[led_stat], 00[led_port]
 00C  25000                                     RETURN 
 00D                                            ;calls led_on function and wait wrt duty_cycle_reg
 00D                               led_on_wait: 
 00D  2000A                                     CALL 00A[led_on]
 00E  00D10                                     LOAD sD[delay_reg], s1[duty_cycle_reg]
 00F  20004                                     CALL 004[delay_reg_loop]
 010  25000                                     RETURN 
 011                                            ;calls led_off function and wait wrt FF-duty_cycle_reg
 011                              led_off_wait: 
 011  20007                                     CALL 007[led_off]
 012  01DFF                                     LOAD sD[delay_reg], FF
 013  18D10                                     SUB sD[delay_reg], s1[duty_cycle_reg]
 014  20004                                     CALL 004[delay_reg_loop]
 015  25000                                     RETURN 
 016                                            ;apply PWM on blink_this_reg led and iterate next led in the direction of MSB
 016                                 go_to_msb: 
 016  2000D                                     CALL 00D[led_on_wait]                          ; set led on and wait
 017  20011                                     CALL 011[led_off_wait]                         ; set led off and wait
 018  1450E                                     SR0 s5[blink_this_reg]                         ; shift blink_this_reg right
 019  1410E                                     SR0 s1[duty_cycle_reg]                         ; divide duty_cycle_reg by 2
 01A  1410E                                     SR0 s1[duty_cycle_reg]                         ; divide duty_cycle_reg by 2
 01B  25000                                     RETURN 
 01C                                            ;apply PWM on blink_this_reg led and iterate next led in the direction of LSB
 01C                                 go_to_lsb: 
 01C  2000D                                     CALL 00D[led_on_wait]                          ; set led on and wait
 01D  20011                                     CALL 011[led_off_wait]                         ; set led off and wait
 01E  14506                                     SL0 s5[blink_this_reg]                         ; shift blink_this_reg left
 01F  1410E                                     SR0 s1[duty_cycle_reg]                         ; divide duty_cycle_reg by 2
 020  1410E                                     SR0 s1[duty_cycle_reg]                         ; divide duty_cycle_reg by 2
 021  25000                                     RETURN 
 022                                            ;this function does nearly everything we want.
 022                                            ;it is a one loop of apply PWM to 3-LED.
 022                                one_period: 
 022  00540                                     LOAD s5[blink_this_reg], s4[which_led_on_reg]  ; we do not want to change which_led_on_reg so lets save it
 023  011FF                                     LOAD s1[duty_cycle_reg], FF                    ; start duty cycle with FF
 024                                            ;blink current led according to direction
 024  1D200                                     COMPARE s2[direction_reg], 00
 025  30016                                     CALL Z, 016[go_to_msb]
 026  1D2FF                                     COMPARE s2[direction_reg], FF
 027  3001C                                     CALL Z, 01C[go_to_lsb]
 028                                            ;blink current+-1 led according to direction
 028  1D200                                     COMPARE s2[direction_reg], 00
 029  30016                                     CALL Z, 016[go_to_msb]
 02A  1D2FF                                     COMPARE s2[direction_reg], FF
 02B  3001C                                     CALL Z, 01C[go_to_lsb]
 02C                                            ;blink current+-2 led according to direction
 02C  1D200                                     COMPARE s2[direction_reg], 00
 02D  30016                                     CALL Z, 016[go_to_msb]
 02E  1D2FF                                     COMPARE s2[direction_reg], FF
 02F  3001C                                     CALL Z, 01C[go_to_lsb]
 030  25000                                     RETURN 
 031                                            ;this thread function simply a delay function
 031                                            ;it's loop's time nearly equals to [FF-delayA_reg]*[FF-delayB_reg]*[Instruction of 'one_period' function]*[2 clock per instruction]
 031                                    thread: 
 031  01A00                                     LOAD sA[delayA_reg], 00                        ;count FF - 00 = FF || 255'd
 032  01BFA                                     LOAD sB[delayB_reg], FA                        ;count FF - FA = 05 || 5'd
 033                              thread_delay: 
 033                                            ;our main process function
 033  20022                                     CALL 022[one_period]
 034                                            ;start of delay part
 034  11A01                                     ADD sA[delayA_reg], 01
 035  36033                                     JUMP NZ, 033[thread_delay]
 036  11B01                                     ADD sB[delayB_reg], 01
 037  36033                                     JUMP NZ, 033[thread_delay]
 038                                            ;end of delay part
 038                                            ;if we are on left-most bit
 038  1D401                                     COMPARE s4[which_led_on_reg], 01               ; if LSB == 1
 039  30042                                     CALL Z, 042[check_for_change_direction_to_msb] ; if direction is to_msb dont change direction
 03A                                            ;if we are on right-most bit
 03A  1D480                                     COMPARE s4[which_led_on_reg], 80               ; if MSB == 1
 03B  30045                                     CALL Z, 045[check_for_change_direction_to_lsb] ; if direction is to_lsb dont change direction
 03C                                            ;update which_led_on_reg according to direction_reg
 03C  1D200                                     COMPARE s2[direction_reg], 00
 03D  32040                                     JUMP Z, 040[go_left]                           ; true
 03E                                            ;false
 03E  1440C                                     RR s4[which_led_on_reg]
 03F  25000                                     RETURN 
 040                                   go_left: 
 040  14402                                     RL s4[which_led_on_reg]                        ;select next led on every iteration
 041  25000                                     RETURN 
 042         check_for_change_direction_to_msb: 
 042  1D2FF                                     COMPARE s2[direction_reg], FF
 043  32048                                     JUMP Z, 048[change_direction]
 044  25000                                     RETURN 
 045         check_for_change_direction_to_lsb: 
 045  1D200                                     COMPARE s2[direction_reg], 00
 046  32048                                     JUMP Z, 048[change_direction]
 047  25000                                     RETURN 
 048                          change_direction: 
 048  1D2FF                                     COMPARE s2[direction_reg], FF
 049  3204C                                     JUMP Z, 04C[direction_00]                      ; equal
 04A                                            ;not equal
 04A  012FF                                     LOAD s2[direction_reg], FF                     ; direction_reg already FF so we can omit this line
 04B  25000                                     RETURN 
 04C                              direction_00: 
 04C  01200                                     LOAD s2[direction_reg], 00
 04D  25000                                     RETURN 
 04E                                            ;==========SUBROUTINES=================
 04E                                            ;============MAIN======================
 04E                                            ; one period of PWM
 04E                                            ; it takes 4u sec to complete
 04E                                      main: 
 04E  20031                                     CALL 031[thread]                               ;
 04F  2204E                                     JUMP 04E[main]                                 ;infinite loop
 050                                            ;============MAIN======================
 050                                            ;; 255*255*190 ~= 12.5M
 050                                            ;; delay routine has 2 INST so 25M INST in total we have
 050                                            ;; 1INST = 2clock cycle so 50M clock cycle we have
 050                                            ;; device frequency is 100Mhz so that 50M clock took 0.5 sec.
 050                                            ;; half cycle took 0.5 sec => full cycle 1sec. :)
 050                                            ;delay_500msec:
 050                                            ; LOAD delayA_reg,00  ;count FF - 00 = FF || 255'd
 050                                            ; LOAD delayB_reg,00  ;count FF - 00 = FF || 255'd
 050                                            ; LOAD delayC_reg,41  ;count FF - 41 = BE || 190'd
 050                                            ; ; delay_sec ~= (FF-delayA_reg)*(FF-delayB_reg)*(FF-delayC_reg)*2*2/100M sec
 050                                            ; delay:
 050                                            ;  ADD delayA_reg, 01
 050                                            ;  JUMP NZ,      delay
 050                                            ;  ADD delayB_reg, 01
 050                                            ;  JUMP NZ,      delay
 050                                            ;  ADD delayC_reg, 01
 050                                            ;  JUMP NZ,      delay
 050                                            ;  RETURN
 050                                            ;
 050                                            ;
 050                                            ;; 50clk_cycle = 1u sec
 050                                            ;; 25INST = 50clk_cycle
 050                                            ;delay_1micro_sec:
 050                                            ; LOAD delay_usec_reg,0C  ;12'd
 050                                            ;delay_1micro_sec_loop:
 050                                            ; SUB delay_usec_reg,01
 050                                            ; JUMP NZ, delay_1micro_sec_loop
 050                                            ; RETURN


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\ugurg\OneDrive\Learnings\Courses\BIL569 Embedded\HW1\src\kitt_blink\kitt_blink.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   22'd         
 timestamp_minutes 02'd         
 timestamp_seconds 13'd         
 datestamp_year    17'd         
 datestamp_month   5'd          
 datestamp_day     31'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 led_port          00           kitt_blink.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "31 May 2017"  
 timestamp$        "22:02:13"     



List of line labels

   Label                               Addr  Source PSM File

   delay_reg_loop                      004   kitt_blink.psm
   led_off                             007   kitt_blink.psm
   led_on                              00A   kitt_blink.psm
   led_on_wait                         00D   kitt_blink.psm
   led_off_wait                        011   kitt_blink.psm
   go_to_msb                           016   kitt_blink.psm
   go_to_lsb                           01C   kitt_blink.psm
   one_period                          022   kitt_blink.psm
   thread                              031   kitt_blink.psm
   thread_delay                        033   kitt_blink.psm
   go_left                             040   kitt_blink.psm
   check_for_change_direction_to_msb   042   kitt_blink.psm
   check_for_change_direction_to_lsb   045   kitt_blink.psm
   change_direction                    048   kitt_blink.psm
   direction_00                        04C   kitt_blink.psm
   main                                04E   kitt_blink.psm



Instruction usage statistics

 Instruction    Instances

 LOAD             13
 STAR              -

 AND               -
 OR                -
 XOR               -

 ADD               2
 ADDCY             -
 SUB               2
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          12
 COMPARECY         -

 SL0               1
 SL1               -
 SLX               -
 SLA               -
 RL                1
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                1

 REGBANK           -

 INPUT             -
 OUTPUT            2
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP              9
 JUMP@             -
 CALL             18
 CALL@             -
 RETURN           14
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
